* Who I am


- Linux enthusiast
- Emacs user/ preacher ~.~
- S/ware dev @ Sibsco

* Literate Programming in Emacs and Org-mode




** What this is not about
 - No editor wars
 - More like sharing ideas that can be "extended" elsewhere

* What's literate programming?


- First coined by Donald Knuth.
- You write documentation containing code
- Programs considered "Works of Literature", hence "literate programming"
- Some literate programs read like a book

* ~



- Some environments have made it explicit: e.g. Jupyter notebooks
- It's not document generation

* The web



- The structure of a software program may be thought of as a "WEB" made up of
  interconnected pieces.
- To document such a program we want to explain each
  individual part of the web and how it relates to its neighbors.

* Core Concepts


- Weaving- documentation
- Tangling- code generation

* What's org?


- One of Emacs' core features
- It was originally created to organize notes
- People extended it to do other things like:
  - Time Tracking
  - Programming
  - Note/ Event taking
  - Blogging
  - etc

* Why literate programming in org mode


- Better docs
- Really handy in code reviews
- Communication made easier
- Thought clarification
- Running code in the same document *.*
- One document with all your source *.*
- Inter-language weirdness is possible
- The power of org's organizational features like agendas and tasks

* Demo Time

- Let's print a number in javascript:
#+BEGIN_SRC js :results output
  console.log('hello world')
#+END_SRC

#+RESULTS:
: hello world

- The same in python:
#+BEGIN_SRC python :results output
  print('hello world')
#+END_SRC

#+RESULTS:
: hello world

* Some weaving(abit extreme)

Let's generate some random characters:

We first get the imports we need


#+NAME: import all our dependencies
#+BEGIN_SRC python :results output
  import random
  import string
#+END_SRC


* ~

Then we print out a random string

#+NAME: print random string
#+BEGIN_SRC python
  random = ''.join([random.choice(string.ascii_letters + string.digits) for n in range(32)])

  print(random)
#+END_SRC

#+RESULTS:

* ~

#+NAME: random-gen
#+BEGIN_SRC python :results output :noweb yes
  <<import all our dependencies>>

  <<print random string>>
#+END_SRC

#+RESULTS: random-gen
: PH4Ka8TdlzlPKzq9wT6AgZatKdFHsKe2

Now, when we put it all together:
We can print the results or source code to a file if you wanted

#+BEGIN_SRC python :results output :noweb yes :file test.txt
  <<import all our dependencies>>

  <<print random string>>
#+END_SRC

#+RESULTS:
[[file:test.txt]]

Outputting the results of the file:
#+BEGIN_SRC sh
  cat test.txt
#+END_SRC

#+RESULTS:
: i8M71BzW76hT1tH0bLiuxQ0zCg8O4I9O

* ~

We can also pass variables to other languages.

#+BEGIN_SRC sh :var input=random-gen()
  echo $input
  printf $input | wc -m
#+END_SRC

#+RESULTS:
| rIWOmgVacVW6fxa3RMzwz4IZEwBI2i5l |
|                               32 |

#+BEGIN_SRC sh :results value org
  man wc
#+END_SRC
* ~




Let's go through some conf files that have grown over the years

- Emacs config file
- tic-tac-toe

* tic-tac-toe: demo
** Normal Workflow
- Discussion with team members
- Notes usually taken into org mode
- Break down a task into manageable and actionable tasks
- Add the tasks to an agenda file
- Track the tasks using some pomodoro
- (Occasionally) generate reports
- (After pulling) sync changes to org file
** Tic Tac Toe game
A tic-tac-toe game in Haskell.

The game is implemented in Haskell.

Motivation: somebody requested me to do this in haskell

Reinforcement learning

The code has no tests
** DONE Base Configuration
CLOSED: [2019-01-05 Sat 17:40]
:LOGBOOK:
CLOCK: [2019-01-05 Sat 17:32]--[2019-01-05 Sat 17:39] =>  0:07
:END:
- The configuration is usually autogenerated by running ```stack init``` in the
  root dir
- Do not touch these files. They are normally auto-generated
- I used the simple template here.
- You really don't need this stuff since the stack will do everything for you

*** stack.yml:

#+BEGIN_SRC haskell :tangle stack.yml
  # This file was automatically generated by 'stack init'
  #
  # Some commonly used options have been documented as comments in this file.
  # For advanced use and comprehensive documentation of the format, please see:
  # http://docs.haskellstack.org/en/stable/yaml_configuration/

  # Resolver to choose a 'specific' stackage snapshot or a compiler version.
  # A snapshot resolver dictates the compiler version and the set of packages
  # to be used for project dependencies. For example:
  #
  # resolver: lts-3.5
  # resolver: nightly-2015-09-21
  # resolver: ghc-7.10.2
  # resolver: ghcjs-0.1.0_ghc-7.10.2
  # resolver:
  #  name: custom-snapshot
  #  location: "./custom-snapshot.yaml"
  resolver: lts-12.14

  # User packages to be built.
  # Various formats can be used as shown in the example below.
  #
  # packages:
  # - some-directory
  # - https://example.com/foo/bar/baz-0.0.2.tar.gz
  # - location:
  #    git: https://github.com/commercialhaskell/stack.git
  #    commit: e7b331f14bcffb8367cd58fbfc8b40ec7642100a
  # - location: https://github.com/commercialhaskell/stack/commit/e7b331f14bcffb8367cd58fbfc8b40ec7642100a
  #   extra-dep: true
  #  subdirs:
  #  - auto-update
  #  - wai
  #
  # A package marked 'extra-dep: true' will only be built if demanded by a
  # non-dependency (i.e. a user package), and its test suites and benchmarks
  # will not be run. This is useful for tweaking upstream packages.
  packages:
  - '.'
  # Dependency packages to be pulled from upstream that are not in the resolver
  # (e.g., acme-missiles-0.3)
  extra-deps: []

  # Override default flag values for local packages and extra-deps
  flags: {}

  # Extra package databases containing global packages
  extra-package-dbs: []

  # Control whether we use the GHC we find on the path
  # system-ghc: true
  #
  # Require a specific version of stack, using version ranges
  # require-stack-version: -any # Default
  # require-stack-version: ">=1.4"
  #
  # Override the architecture used by stack, especially useful on Windows
  # arch: i386
  # arch: x86_64
  #
  # Extra directories used by stack for building
  # extra-include-dirs: [/path/to/dir]
  # extra-lib-dirs: [/path/to/dir]
  #
  # Allow a newer minor version of GHC than the snapshot specifies
  # compiler-check: newer-minor
  #nix:
  #  enable: true
  #  packages: [glpk, pcre]
#+END_SRC

*** Setup.hs:
#+BEGIN_SRC haskell :tangle Setup.hs
  import Distribution.Simple
  main = defaultMain
#+END_SRC

*** tictactoe-hs.cabal:
You can change the executable to anything you want.
Also ensure that you have random in the build-depends
otherwise things won't work

Things break if you don't add the LICENSE and README file
#+BEGIN_SRC haskell :tangle tictactoe-hs.cabal
  name:                tictactoe-hs
  version:             0.1.0.0
  -- synopsis:
  -- description:
  homepage:            bonfacemunyoki.com
  license:             BSD3
  license-file:        LICENSE
  author:              Bonface K. M.
  maintainer:          bonfacemunyoki@gmail.com
  copyright:           2018, BMK
  category:            Game
  build-type:          Simple
  cabal-version:       >=1.10
  extra-source-files:  README.md

  executable ttt
    hs-source-dirs:      src
    main-is:             Main.hs
    default-language:    Haskell2010
    build-depends:       base >= 4.7 && < 5
                       , random
    other-modules:       TicTacToeLib

  library
    hs-source-dirs:      src
    exposed-modules:     TicTacToeLib
    default-language:    Haskell2010
    build-depends:       base >= 4.7 && < 5
                       , random
#+END_SRC

*** LICENSE
#+BEGIN_SRC text :tangle LICENSE
  Copyright Ben Lovy (c) 2018

  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

      ,* Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

      ,* Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution.

      ,* Neither the name of Ben Lovy nor the names of other
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#+END_SRC

*** README
#+BEGIN_SRC markdown :tangle README
  # tictactoe-hs
  TicTacToe in Haskell.

  `stack install` to build and install `ttt` executable.  Remember to set an alarm.  You can't afford another TicTacToe all-nighter and you know it.
#+END_SRC

** The game
*** DONE Project dependencies
CLOSED: [2019-01-05 Sat 17:46]
:PROPERTIES:
:ORDERED:  t
:END:
:LOGBOOK:
CLOCK: [2019-01-05 Sat 17:45]--[2019-01-05 Sat 17:46] =>  0:01
:END:
- Note the aligning- it makes things easy to read
- Stick to code guidelines

#+NAME: imports
#+BEGIN_SRC haskell
  import Control.Monad (forever, when)
  import Data.Bool     (bool)
  import Data.Char     (digitToInt)
  import Data.List     (isSubsequenceOf)
  import Data.Maybe    (isJust, isNothing)
  import System.Exit   (exitSuccess)
  import System.IO     (hFlush, stdout)
  import System.Random (randomRIO)
#+END_SRC

*** DONE Create our data types
CLOSED: [2019-01-05 Sat 17:51]
- We need a board
- We also need to describe how our board will be displayed
- Something like this:
           1 2 3
           4 5 6
           7 8 9
- Each element in the board is a cell.
- Make code less cryptic - LUG
#+NAME: create the board data type
#+BEGIN_SRC haskell
  newtype Board = Board [Maybe Player]
  data Player = Human | Computer deriving (Eq, Show)

  instance Show Board where
    show (Board cs) = foldr spaceEachThird [] . withIndicesFrom 1 . fmap showCell $ withIndicesFrom 1 cs
      where spaceEachThird a = (++) (bool (snd a) (snd a ++ "\n") (fst a `rem` 3 == 0))
#+END_SRC

*** DONE Win states
CLOSED: [2019-01-05 Sat 17:56]
- Earlier considerations:
  - Create function that checks diagonal, horizontal, and vertical for wins
  - Too much work
- Instead, have a list with the win states
- Lazy but efficient

 #+NAME: win states
 #+BEGIN_SRC haskell
   -- All the states that indicate a win in the game
   winStates :: [[Int]]
   winStates = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]
 #+END_SRC

*** DONE Cell Functions
CLOSED: [2019-01-05 Sat 18:10]
- We need to have functions that operate on a cell

- Here all the functions that operate in a cell in a nutshell
#+NAME: declare all cell functions
#+BEGIN_SRC haskell :noweb yes
  <<show a cell>>

  <<check if a cell is open>>

  <<play a cell>>
#+END_SRC

- Here's an example of a board(it won't be displayed like that though):

  | (1, Nothing) | (2, Just Human)   | (3, Nothing)         |
  |--------------+-------------------+----------------------|
  | (4, Nothing) | (5, Nothing)      | (6, Nothing)         |
  |--------------+-------------------+----------------------|
  | (7, Nothing) | (8, Nothing)      | (9, Just Computer)   |

- So we need a function that can display cells. The above board would look sth like this:
           | 1 | X | 3 |
           |---+---+---|
           | 4 | 5 | 6 |
           |---+---+---|
           | 7 | 8 | O |

#+NAME: show a cell
#+BEGIN_SRC haskell
  -- An empty cell shows its number on the grid,
  -- A play made by a human is represented with a: " X "
  -- and that by a computer with a: " O "
  showCell :: (Int, Maybe Player) -> String
  showCell (n, Nothing)         = " " ++ show n ++ " "
  showCell (_, (Just Human))    = " X "
  showCell (_, (Just Computer)) = " O "
#+END_SRC

- Before a player plays a cell, we need to check that the cell is free

#+NAME: check if a cell is open
#+BEGIN_SRC haskell
  isCellOpen :: Board -> Int -> Bool
  isCellOpen (Board b) n = isNothing $ b !! (n - 1)
#+END_SRC

- We need a fn that can play a cell. If you choose a num, it returns a board
  with the cell filled by the player

#+NAME: play a cell
#+BEGIN_SRC haskell
  playCell :: Board -> Int -> Player -> Board
  playCell (Board b) n player = Board $ prePlayerCells ++ [Just player] ++ postPlayerCells
    where prePlayerCells = take (n - 1) b
          postPlayerCells = drop n b
#+END_SRC

*** DONE Board Functions
CLOSED: [2019-01-05 Sat 18:13]

We need to be able to:
- generate an empty board
- enable a computer to play
- enable a human to play
- check the wins
- check for draws

When we put it all together:

#+NAME: declare all board functions
#+BEGIN_SRC haskell :noweb yes
  <<generate an empty board>>

  <<enable a computer to play>>

  <<enable a human to play>>

  <<check for wins>>

  <<check for draws>>
#+END_SRC

First, we generate an empty board which has nothing. There's also a generic
function that will be used by the other board functions

#+NAME: generate an empty board
#+BEGIN_SRC haskell
  freshBoard :: Board
  freshBoard = Board $ replicate 9 Nothing

  withIndicesFrom :: Int -> [a] -> [(Int, a)]
  withIndicesFrom n = zip [n..]
#+END_SRC

The computer's play is driven by a random number. You get all the free positions
then randomly choose one. After the play, we check for a win. We return a board
wrapped in a monad(a haskellish way of dealing with side fx)

#+NAME: enable a computer to play
#+BEGIN_SRC haskell
  compTurn :: Board -> IO Board
  compTurn board@(Board b) = do
    let options = filter (isNothing . snd) . withIndicesFrom 1 $ b
    r <- randomRIO (0, length options - 1)
    let play = (fst $ options !! r)
    let b2 = playCell board play Computer
    putStrLn $ "Computer plays " ++ show play
    checkWin b2 Computer
    return b2
#+END_SRC

Same concept with a human play.
#+NAME: enable a human to play
#+BEGIN_SRC haskell
  humanTurn :: Board -> Int -> IO Board
  humanTurn board n = do
    let b = playCell board n Human
    checkWin b Human
    checkDraw b
    return b
#+END_SRC

To check a win, we check if there's a sub-sequence of the win-states. If it exists,
we end the game and declare the winner

#+NAME: check for wins
#+BEGIN_SRC haskell
  checkWin :: Board -> Player -> IO ()
  checkWin board@(Board b) m =
    let
      bi = withIndicesFrom 0 b
      plays = map fst . filter ((Just m ==) . snd) $ bi
    in
     when (foldr ((||) . flip isSubsequenceOf plays) False winStates) $ do
       print board
       putStrLn $ show m ++ " won!"
       exitSuccess
#+END_SRC

We really don't need to check for losses. A win implies a loss to the other;
Also checking for wins is really easier.

For draws, when all cells are filled with no wins declared, it's a draw.

#+NAME: check for draws
#+BEGIN_SRC haskell
  checkDraw :: Board -> IO ()
  checkDraw board@(Board b) =
    when ( all isJust b) $ do
      print board
      putStrLn "Draw!"
      exitSuccess
#+END_SRC

*** DONE Running the game
CLOSED: [2019-01-05 Sat 18:13]
- The game runs in an infinite loop
- Here's the algorithm for running this game:
  - check the draw
  - print the board
  - get the move from the human
  - if the move is valid, the comp plays
  - otherwise raise some warning

#+NAME: run the game
#+BEGIN_SRC haskell
  runGame :: Board -> IO ()
  runGame board = forever $ do
    checkDraw board
    print board
    putStr "Your move: "
    hFlush stdout
    n <- getLine
    case n of
      [c] ->
        if [c] `elem` map show [(1::Integer)..9]
        then do
            let n' = digitToInt c
            if isCellOpen board n'
            then humanTurn board n' >>= compTurn >>= runGame
            else putStrLn "That's taken!"
        else putStrLn "1-9 only please"
      _   -> putStrLn "Only one digit allowed!"
#+END_SRC
*** DONE The Game
CLOSED: [2019-01-05 Sat 19:00]
- I put the game logic in one file src/TicTacToe.hs

#+BEGIN_SRC haskell :tangle src/TicTacToe.hs :noweb yes :mkdirp yes
  <<imports>>

  <<create the board data type>>

  <<win states>>

  <<declare all cell functions>>

  <<declare all board functions>>

  <<run the game>>
#+END_SRC

- The game will be run here:
#+BEGIN_SRC haskell :tangle src/Main.hs :noweb yes :mkdirp yes
  module Main where

  import TicTacToeLib

  main :: IO ()
  main = do
    let board = freshBoard
    runGame board
#+END_SRC

* Challenges



- Reverse Tangling can be a problem
- Syncing and debugging
- Setting up org files to some people is a chore
